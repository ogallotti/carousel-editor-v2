#!/usr/bin/env python3
"""
Generate images for a carousel via the KIE API (kie.ai).

Supports three models:
  - gpt-image/1.5-text-to-image  (preferred — text to image)
  - gpt-image/1.5-image-to-image (image to image, needs input_urls)
  - nano-banana-pro              (Gemini 3 Pro, supports 4:5 ratio)

Usage:
  # From a prompt pack (generated by build_prompt_pack.py):
  python3 generate_images.py --prompt-pack prompt-pack.json --output-dir carousel-build/assets/

  # Single image:
  python3 generate_images.py --prompt "Editorial photo..." --output-dir carousel-build/assets/ --filename hero.jpg

  # With specific model:
  python3 generate_images.py --prompt "..." --model nano-banana-pro --aspect-ratio 4:5 --output-dir assets/

Environment:
  KIE_API_KEY  — Bearer token from https://kie.ai/api-key
"""
from __future__ import annotations

import argparse
import json
import os
import sys
import time
import urllib.request
import urllib.error
from pathlib import Path

BASE_URL = "https://api.kie.ai/api/v1/jobs"
DEFAULT_MODEL = "gpt-image/1.5-text-to-image"
POLL_INTERVAL = 4  # seconds
MAX_POLL_ATTEMPTS = 120  # ~8 minutes max wait


def get_api_key():
    # type: () -> str
    key = os.environ.get("KIE_API_KEY", "")
    if not key:
        print("Erro: variavel de ambiente KIE_API_KEY nao definida.", file=sys.stderr)
        print("Obter em: https://kie.ai/api-key", file=sys.stderr)
        sys.exit(1)
    return key


def api_request(method, url, data=None, api_key=None):
    # type: (str, str, dict|None, str|None) -> dict
    headers = {"Content-Type": "application/json"}
    if api_key:
        headers["Authorization"] = "Bearer " + api_key

    body = json.dumps(data).encode("utf-8") if data else None
    req = urllib.request.Request(url, data=body, headers=headers, method=method)

    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            return json.loads(resp.read().decode("utf-8"))
    except urllib.error.HTTPError as e:
        error_body = ""
        try:
            error_body = e.read().decode("utf-8")
        except Exception:
            pass
        print(f"HTTP {e.code}: {error_body}", file=sys.stderr)
        sys.exit(1)
    except urllib.error.URLError as e:
        print(f"Erro de conexao: {e.reason}", file=sys.stderr)
        sys.exit(1)


def create_task(model, input_params, api_key):
    # type: (str, dict, str) -> str
    payload = {"model": model, "input": input_params}
    resp = api_request("POST", BASE_URL + "/createTask", data=payload, api_key=api_key)

    if resp.get("code") != 200:
        print(f"Erro ao criar tarefa: {resp.get('msg', 'unknown')}", file=sys.stderr)
        sys.exit(1)

    task_id = resp["data"]["taskId"]
    print(f"  Tarefa criada: {task_id}")
    return task_id


def poll_task(task_id, api_key):
    # type: (str, str) -> dict
    url = BASE_URL + "/recordInfo?taskId=" + task_id

    for attempt in range(1, MAX_POLL_ATTEMPTS + 1):
        resp = api_request("GET", url, api_key=api_key)
        data = resp.get("data", {})
        state = data.get("state", "unknown")

        if state == "success":
            result = json.loads(data.get("resultJson", "{}"))
            urls = result.get("resultUrls", [])
            cost = data.get("costTime")
            cost_str = f" ({cost}ms)" if cost else ""
            print(f"  Concluido{cost_str}: {len(urls)} imagem(ns)")
            return result

        if state == "fail":
            fail_msg = data.get("failMsg", "sem detalhes")
            fail_code = data.get("failCode", "?")
            print(f"  Falhou [{fail_code}]: {fail_msg}", file=sys.stderr)
            return {}

        # Still waiting
        if attempt % 5 == 0:
            print(f"  Aguardando... (tentativa {attempt}/{MAX_POLL_ATTEMPTS})")
        time.sleep(POLL_INTERVAL)

    print("  Timeout: tarefa nao concluiu a tempo.", file=sys.stderr)
    return {}


def download_image(url, output_path):
    # type: (str, Path) -> bool
    try:
        req = urllib.request.Request(url)
        with urllib.request.urlopen(req, timeout=60) as resp:
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_bytes(resp.read())
        print(f"  Salvo: {output_path}")
        return True
    except Exception as e:
        print(f"  Erro ao baixar {url}: {e}", file=sys.stderr)
        return False


def generate_single(prompt, model, aspect_ratio, quality, resolution, output_format,
                    input_urls, output_dir, filename, api_key):
    # type: (str, str, str, str, str|None, str|None, list|None, Path, str, str) -> tuple
    """Generate a single image and download it.

    Returns (success: bool, image_url: str|None) — the remote URL is kept
    so it can be reused as input_urls reference for subsequent i2i calls.
    """
    input_params = {"prompt": prompt}

    if model == "nano-banana-pro":
        input_params["aspect_ratio"] = aspect_ratio
        if resolution:
            input_params["resolution"] = resolution
        if output_format:
            input_params["output_format"] = output_format
        if input_urls:
            input_params["input_urls"] = input_urls
    elif model == "gpt-image/1.5-image-to-image":
        input_params["aspect_ratio"] = aspect_ratio
        input_params["quality"] = quality
        if not input_urls:
            print("Erro: gpt-image/1.5-image-to-image requer input_urls", file=sys.stderr)
            return False, None
        input_params["input_urls"] = input_urls
    else:
        # gpt-image/1.5-text-to-image
        input_params["aspect_ratio"] = aspect_ratio
        input_params["quality"] = quality

    print(f"\nGerando: {filename}")
    print(f"  Modelo: {model}")
    print(f"  Ratio: {aspect_ratio} | Quality: {quality}")
    if input_urls:
        print(f"  Referencia: {len(input_urls)} imagem(ns)")

    task_id = create_task(model, input_params, api_key)
    result = poll_task(task_id, api_key)

    urls = result.get("resultUrls", [])
    if not urls:
        print(f"  Sem imagens no resultado.", file=sys.stderr)
        return False, None

    # Download first result
    image_url = urls[0]

    # Detect extension from URL if filename has no extension
    out_path = output_dir / filename
    if not out_path.suffix:
        if ".png" in image_url:
            out_path = out_path.with_suffix(".png")
        elif ".webp" in image_url:
            out_path = out_path.with_suffix(".webp")
        else:
            out_path = out_path.with_suffix(".jpg")

    ok = download_image(image_url, out_path)
    return ok, image_url if ok else None


def generate_from_prompt_pack(pack_path, model, aspect_ratio, quality, resolution,
                               output_format, output_dir, api_key, no_ref=False):
    # type: (Path, str, str, str, str|None, str|None, Path, str, bool) -> None
    """Generate all images from a prompt pack JSON.

    Default behaviour (hero-first consistency):
      1. Title typography via text-to-image (no reference)
      2. Hero editorial via text-to-image (VISUAL ANCHOR)
      3. Scene images via image-to-image using the hero URL as reference

    Pass no_ref=True to disable the i2i flow and generate all via text-to-image.
    """
    pack = json.loads(pack_path.read_text(encoding="utf-8"))
    prompts = pack.get("prompts", {})

    total_images = 0
    success_count = 0
    hero_url = None  # captured after hero generation

    # 1. Title typography — always text-to-image, no reference
    title_prompt = prompts.get("title")
    if title_prompt:
        total_images += 1
        print("\n=== Titulo Tipografico ===")
        ok, _ = generate_single(
            prompt=title_prompt,
            model=model,
            aspect_ratio=aspect_ratio,
            quality="high",
            resolution=resolution,
            output_format="png",
            input_urls=None,
            output_dir=output_dir,
            filename="cover-title.png",
            api_key=api_key,
        )
        if ok:
            success_count += 1

    # 2. Hero editorial — text-to-image, quality high (VISUAL ANCHOR)
    editorial_prompt = prompts.get("editorial")
    if editorial_prompt:
        total_images += 1
        print("\n=== Hero Editorial (ancora visual) ===")
        ok, hero_url = generate_single(
            prompt=editorial_prompt,
            model=model,
            aspect_ratio=aspect_ratio,
            quality="high",
            resolution=resolution,
            output_format=output_format,
            input_urls=None,
            output_dir=output_dir,
            filename="hero-editorial.jpg",
            api_key=api_key,
        )
        if ok:
            success_count += 1

    # 3. Scene sequence — image-to-image with hero as reference (default)
    scenes = prompts.get("scenes", [])

    if hero_url and not no_ref:
        print(f"\n>>> Usando hero como referencia para consistencia visual (i2i)")
        scene_model = "gpt-image/1.5-image-to-image"
        scene_input_urls = [hero_url]
    else:
        if not no_ref and scenes:
            print("\n>>> Hero nao disponivel — fallback para text-to-image puro")
        scene_model = model
        scene_input_urls = None

    for scene in scenes:
        scene_num = scene.get("scene", 0)
        scene_prompt = scene.get("prompt", "")
        if not scene_prompt:
            continue

        total_images += 1
        print(f"\n=== Cena {scene_num} ===")
        ok, _ = generate_single(
            prompt=scene_prompt,
            model=scene_model,
            aspect_ratio=aspect_ratio,
            quality=quality,
            resolution=resolution,
            output_format=output_format,
            input_urls=scene_input_urls,
            output_dir=output_dir,
            filename=f"scene-{scene_num:02d}.jpg",
            api_key=api_key,
        )
        if ok:
            success_count += 1

    print(f"\n{'='*40}")
    print(f"Resultado: {success_count}/{total_images} imagens geradas com sucesso")
    print(f"Diretorio: {output_dir}")

    if success_count == 0:
        print("ERRO: Nenhuma imagem gerada. Verifique a API key e conexao.", file=sys.stderr)
        sys.exit(1)
    elif success_count < total_images:
        failed = total_images - success_count
        print(f"AVISO: {failed} imagem(ns) falharam. Regenerar manualmente as faltantes.", file=sys.stderr)
        sys.exit(2)


def main():
    parser = argparse.ArgumentParser(
        description="Gerar imagens para carrossel via KIE API (kie.ai)."
    )

    # Input mode
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--prompt-pack", type=Path,
                       help="JSON do prompt pack (gerado por build_prompt_pack.py)")
    group.add_argument("--prompt", type=str,
                       help="Prompt unico para gerar uma imagem")

    # Output
    parser.add_argument("--output-dir", type=Path, required=True,
                        help="Diretorio de saida para as imagens")
    parser.add_argument("--filename", type=str, default="image",
                        help="Nome do arquivo (modo --prompt unico)")

    # Model config
    parser.add_argument("--model", type=str, default=DEFAULT_MODEL,
                        choices=["gpt-image/1.5-text-to-image",
                                 "gpt-image/1.5-image-to-image",
                                 "nano-banana-pro"],
                        help="Modelo de geracao (default: gpt-image/1.5-text-to-image)")
    parser.add_argument("--aspect-ratio", type=str, default="2:3",
                        help="Aspect ratio (default: 2:3). Gemini suporta 4:5")
    parser.add_argument("--quality", type=str, default="high",
                        choices=["medium", "high"],
                        help="Qualidade (GPT models only, default: high)")

    # Gemini-specific
    parser.add_argument("--resolution", type=str, default=None,
                        choices=["1K", "2K", "4K"],
                        help="Resolucao (nano-banana-pro only)")
    parser.add_argument("--output-format", type=str, default=None,
                        choices=["png", "jpg"],
                        help="Formato de saida (nano-banana-pro only)")

    # Image-to-image
    parser.add_argument("--input-urls", type=str, nargs="+", default=None,
                        help="URLs de imagens de referencia (image-to-image)")

    # Consistency mode
    parser.add_argument("--no-ref", action="store_true", default=False,
                        help="Desabilitar fluxo hero-as-reference: gera todas via text-to-image")

    args = parser.parse_args()
    api_key = get_api_key()

    args.output_dir.mkdir(parents=True, exist_ok=True)

    if args.prompt_pack:
        generate_from_prompt_pack(
            pack_path=args.prompt_pack,
            model=args.model,
            aspect_ratio=args.aspect_ratio,
            quality=args.quality,
            resolution=args.resolution,
            output_format=args.output_format,
            output_dir=args.output_dir,
            api_key=api_key,
            no_ref=args.no_ref,
        )
    else:
        ok, _ = generate_single(
            prompt=args.prompt,
            model=args.model,
            aspect_ratio=args.aspect_ratio,
            quality=args.quality,
            resolution=args.resolution,
            output_format=args.output_format,
            input_urls=args.input_urls,
            output_dir=args.output_dir,
            filename=args.filename,
            api_key=api_key,
        )
        if not ok:
            sys.exit(1)


if __name__ == "__main__":
    main()
